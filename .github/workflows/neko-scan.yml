name: Neko Security Scan
on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:
    inputs:
      target:
        description: 'Scan target (e.g. GitHub URL or local path)'
        required: true
        default: 'https://github.com/lightsparkdev/python-sdk'
      model:
        description: 'LLM Model'
        required: true
        default: 'qwen3-coder-plus'
      encryption_password:
        description: 'Password for decrypting tokens (optional - will use ENCRYPTION_PASSWORD secret if not provided)'
        required: false
        default: ''

jobs:
  neko-scan:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Cache Docker layers
        uses: actions/cache@v4
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-

      - name: Decrypt QWEN_TOKENS
        id: decrypt
        env:
          QWEN_TOKENS: ${{ secrets.QWEN_TOKENS }}
          # Priority: 1) Manual input, 2) Repository secret
          ENCRYPTION_PASSWORD: ${{ github.event.inputs.encryption_password || secrets.ENCRYPTION_PASSWORD }}
        run: |
          set -e
          
          # Validate QWEN_TOKENS secret
          if [ -z "$QWEN_TOKENS" ]; then
            echo "::error::QWEN_TOKENS secret is missing! Please add it to repository secrets."
            exit 1
          fi
          
          # Validate ENCRYPTION_PASSWORD (from input or secret)
          if [ -z "$ENCRYPTION_PASSWORD" ]; then
            echo "::error::ENCRYPTION_PASSWORD is not set! Either provide it as workflow input or set ENCRYPTION_PASSWORD secret."
            exit 1
          fi
          
          echo "::group::Decrypting tokens"
          
          # Clean and decode base64 - handle various encoding issues
          # 1. Remove all whitespace (spaces, tabs, newlines, carriage returns)
          # 2. Remove any URL-safe base64 characters and convert to standard base64
          # 3. Handle potential padding issues
          CLEANED_TOKEN=$(echo "$QWEN_TOKENS" | tr -d '[:space:]' | tr '_-' '/+')
          
          # Add padding if needed (base64 strings should be divisible by 4)
          PADDING=$((4 - ${#CLEANED_TOKEN} % 4))
          if [ $PADDING -ne 4 ]; then
            CLEANED_TOKEN="${CLEANED_TOKEN}$(printf '=%.0s' $(seq 1 $PADDING))"
          fi
          
          # Decode base64 with better error handling
          if ! echo "$CLEANED_TOKEN" | base64 -d > qwen-tokens.enc 2>/dev/null; then
            echo "::error::Failed to decode QWEN_TOKENS. The base64 encoding appears to be invalid."
            echo "::error::Token length: ${#QWEN_TOKENS}, Cleaned length: ${#CLEANED_TOKEN}"
            exit 1
          fi
          
          echo "Base64 decode successful ($(stat -c%s qwen-tokens.enc) bytes)"
          
          # Decrypt with OpenSSL
          if ! openssl enc -aes-256-cbc -d -salt -pbkdf2 \
            -in qwen-tokens.enc \
            -out qwen-tokens.tar.gz \
            -pass pass:"$ENCRYPTION_PASSWORD" 2>/dev/null; then
            echo "::error::OpenSSL decryption failed. Check if ENCRYPTION_PASSWORD is correct."
            exit 1
          fi
          
          echo "OpenSSL decryption successful ($(stat -c%s qwen-tokens.tar.gz) bytes)"
          
          # Extract tokens
          mkdir -p ~/.cli-proxy-api/auth
          if ! tar -xzf qwen-tokens.tar.gz -C ~/.cli-proxy-api/auth 2>/dev/null; then
            echo "::error::Failed to extract token archive. The decrypted file may be corrupted."
            exit 1
          fi
          
          # Count and report token files
          TOKEN_COUNT=$(ls ~/.cli-proxy-api/auth/qwen-*.json 2>/dev/null | wc -l || echo "0")
          echo "Extracted $TOKEN_COUNT token file(s)"
          echo "token_count=$TOKEN_COUNT" >> $GITHUB_OUTPUT
          
          if [ "$TOKEN_COUNT" -eq 0 ]; then
            echo "::warning::No qwen-*.json token files found after extraction!"
          fi
          
          echo "::endgroup::"
          echo "âœ… Token decryption completed successfully"

      - name: Build Neko Agent
        uses: docker/build-push-action@v5
        with:
          context: .
          load: true
          tags: neko-agent:latest
          cache-from: type=local,src=/tmp/.buildx-cache
          cache-to: type=local,dest=/tmp/.buildx-cache-new,mode=max

      - name: Start CLIProxyAPI
        run: |
          curl -L https://github.com/router-for-me/CLIProxyAPI/releases/latest/download/CLIProxyAPI-linux-amd64 -o cliproxy
          chmod +x cliproxy
          # Start in background, it will pick up tokens from ~/.cli-proxy-api/auth
          ./cliproxy > cliproxy.log 2>&1 &
          sleep 5

      - name: Run Neko Scan
        env:
          NEKODB_TOKEN: ${{ secrets.NEKODB_TOKEN }}
          NEKODB_REPO: ${{ github.repository_owner }}/NekoDB
          TARGET_INPUT: ${{ github.event.inputs.target }}
        run: |
          # If target is a URL, clone it first
          if [[ "$TARGET_INPUT" == http* ]]; then
            git clone "$TARGET_INPUT" /tmp/scan-target
            TARGET_VOLUME="/tmp/scan-target"
          else
            TARGET_VOLUME="${{ github.workspace }}"
          fi

          docker run --network host \
            -v "$TARGET_VOLUME":/workspace \
            -e NEKODB_TOKEN=$NEKODB_TOKEN \
            -e NEKODB_REPO=$NEKODB_REPO \
            -e TARGET_PATH=/workspace \
            -e MODEL=${{ github.event.inputs.model || 'qwen3-coder-plus' }} \
            neko-agent:latest

      - name: Move cache
        run: |
          rm -rf /tmp/.buildx-cache
          mv /tmp/.buildx-cache-new /tmp/.buildx-cache
