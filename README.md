# üê± Neko: The Absolute Unit Bug Bounty AI

Neko is a state-of-the-art, **white-box ONLY** autonomous security agent designed to live and hunt within the GitHub CI/CD environment. Combining the architectural precision of **Shannon** with the aggressive multi-agent orchestration of **Strix**, Neko is built to be a "monster" at identifying and validating exploitable vulnerabilities in source code.

## üöÄ Key Features

-   **Active Commander Architecture**: Neko doesn't just delegate; it leads. The Commander agent maps the architecture and performs hands-on testing while managing specialized sub-agents.
-   **Shannon-Style Reconnaissance**: Phase 1 is a deep dive into the repository to map **Entities, Flows, Guards, and Roles**, ensuring the agents understand the "trust boundaries" before they start hunting.
-   **Autonomous Agent Tree**: Just like Strix, Neko spawns hyper-specialized sub-agents (e.g., "JWT Bypass Specialist", "SQLi Tracer") to explore specific attack vectors in parallel.
-   **Monster Toolset**: Pre-baked with over 70+ security tools including Semgrep, CodeQL, Nuclei, SQLmap, TruffleHog, Gitleaks, and many more.
-   **NekoDB Persistence**: A dedicated GitHub-backed database system that tracks sessions, exploits, methodologies, and findings across runs.
-   **Pure HTTP Integration**: Direct communication with **CLIProxyAPI** (supporting Qwen Code, Claude, etc.) without the overhead or limitations of LiteLLM.
-   **CI/CD Native**: Seamlessly integrates into GitHub Actions, triggering on every PR or push to find bugs before they hit production.

## üõ†Ô∏è Components

-   **`neko/agents/commander.py`**: The core "Active Commander" logic.
-   **`neko/db/nekodb.py`**: Persistence layer using GitHub API.
-   **`neko/llm/cliproxy_client.py`**: High-performance, pure HTTP LLM client.
-   **`neko/prompts/`**: Advanced Jinja2 templates for reconnaissance and agent orchestration.
-   **`Dockerfile`**: A battle-hardened Kali Linux container with the full security arsenal.

## üö¶ Getting Started

### 1. Token Collection
Neko uses Qwen Code accounts for its "brain". Use the **Qwen Code Multi-Account Token Collection** workflow (`Neko-Collector.yml`) to gather and encrypt your tokens.
-   Run the workflow via `workflow_dispatch`.
-   Provide a strong encryption password.
-   Follow the interactive logs to authenticate your accounts.
-   Save the resulting `QWEN_TOKENS` secret in your repository.

### 2. Configuration
Add the following secrets to your GitHub Repository:
-   `QWEN_TOKENS`: The encrypted token bundle from the collector.
-   `ENCRYPTION_PASSWORD`: The password you used during collection.
-   `NEKODB_TOKEN`: A GitHub PAT with `repo` scope to allow Neko to write to your `NekoDB` repository.

### 3. Running a Scan
The **Neko Security Scan** workflow (`neko-scan.yml`) will automatically trigger on push/PR, or can be run manually.

## üõ°Ô∏è Security Arsenal
Neko's Docker container includes:
-   **SAST**: Semgrep, Bandit, Checkov, Gosec, ESLint-Security.
-   **Secrets**: TruffleHog, Gitleaks, Detect-Secrets.
-   **SCA**: Trivy, Grype, OSV-Scanner.
-   **DAST/Exploitation**: SQLmap, Commix, Nuclei, Katana, FFUF, Metasploit.
-   **Recon**: Nmap, Subfinder, Httpx, Naabu.

---
*Generated by Neko - The Absolute Unit of White-Box Scanning.*
